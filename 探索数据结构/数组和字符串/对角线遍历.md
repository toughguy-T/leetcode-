### 对角线遍历
给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。  
#### 示例：
```
输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

输出:  [1,2,4,7,5,3,6,8,9]
```

解释:  
![diagonalOrder](https://github.com/toughguy-T/leetcode-/blob/master/%E6%8E%A2%E7%B4%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/diagonal_traverse.png)
#### 说明  
给定矩阵中的元素总数不会超过 100000 。  

#### 惭愧，对这道题没有思路，直接看了题解。  
#### 官方题解，方法一：  
首先明确几个规律和定理：  
对于一个MxN的矩阵。同一个方向上的45°线共有M+N-1条；  
从右上到左下的对角线，遍历方法为：行数+1，列数-1，判断好边界；
对于偶数个对角线，需要逆序
#### 算法：
-  初始化数组 result，用于存储最后结果。  
-  使用一个外层循环遍历所有的对角线。第一行和最后一列的元素都是对角线的起点。  
-  使用一个内层 while 循环遍历对角线上的所有元素。可以计算指定对角线上的元素数量，也可以简单迭代直到索引超出范围。  
-  因为不知道每条对角线上的元素数量，需要为每条对角线分配一个列表或动态数组。但是同样也可以通过计算得到当前对角线上的元素数量。  
-  对于奇数编号的对角线，只需要将迭代结果翻转再加入结果数组即可。  
#### java实现  
```
   public int[] findDiagonalOrder(int[][] matrix) {
       //check for empty matrices
       if (matrix==null || matrix.length==0) {
           return new int[0];
       }
       // variables to track the size of matrix
       int m = matrix.length, n = matrix[0].length;
       // result array
       int[] result = new int[m * n];
       // diagonal array list
       LinkedList<Integer> list = new LinkedList<>();
       int index=0;
       // travers all diagnoals
       for (int d=0; d<m+n-1; d++) {
           // clear the intermediate array every time we start to process another diagnoal
           list.clear();
           // figure out every diagonal's fist coordinate
           int row, col;
           if (d < n) {
               row = 0;
               col = d;
           } else {
               row = d - n + 1;
               col = n - 1;
           }
           // travers elements of diagnoal
           while (row < m && col > -1) {
               list.add(matrix[row][col]);
               row ++;
               col --;
           }
           // reverse even numbered diagonals
           if (d % 2 == 0) {
               Collections.reverse(list);
           }
           for (Integer integer : list) {
               result[index++] = integer;
           }
       }
       return result;
   }
```
#### 分析   
-  时间复杂度：O(N⋅M)，数组有 N 行 M 列。对于所有奇数对角线上的元素，需要两次处理，迭代和翻转。为了节省空间，需要遍历新对角线之前清除中间使用的空间，该操作需要 O(K) 的复杂度度，其中 KK 是数组长度。因此至少处理两次数组中的元素，渐进复杂度为 O(N·M)。
-  空间复杂度：O(min(N, M))，额外空间用于存储每条对角线的中间数组，该数组长度为 N 和 M 的最小值。注意：对角线延伸到索引超出范围结束。  
